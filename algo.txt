EXPLICATION DE CERTAINE PARTIE DU CODE UN PEU COMPLIQUER A COMPRENDRE:

Description integrale Composant Select: 

En premier on a un composant "Select" qui fabrique un collapse generic (utiliser dans 
le formulaire aussi). Il reçois plusieurs props (6 en tout). 
Ensuite des states sont mis en place, un pour la value et un qui initialise "truly" le collapse. 
On a ensuite une fonction changeValue qui est utiliser pour gerer la modification de la valeur du collapse (soirée, experience ..)
Maintenant place a l'élément return, il contient une premiere div "SelectContainer" qui va englober tout le collapse
Ensuite si label est true alors il fabrique une div qui va contenir le label,
Ensuite on a une div "Select" qui va englober le reste du code, dans cette div on a une ul qui contient un premier
li qui prend un parametre que si collapse est truly alors le titre est montrer sinon il est cacher. Dans cette 
li on a soit une value OU si titleEmpty est falsy alors il affiche la chaine "Toutes".
Maintenant on passe au reste de se container select car il va etre fait dynamiquement, on a un gros bout 
de code qui est contenu dans une condition : si collapse est falsy (donc ouvert) voici ce qui passe : 
On a un premier li qui est entourer de la condition si titleEmpty est falsy, il nous permet d'afficher par 
defaut le filtre "Toutes" et aussi de fabriquer un input ("Toutes") qui nous permettera de le selectionner. 
Ensuite on a un selection.map qui va nous mapper tout les element present dans selection ce qui va 
nous permettre d'avoir un li contenant un input radio pour chaque filtre. Cette li en Onclick il 
prend la fonction changeValue. 
Maintenant la ul se ferme 
Ensuite on a un input que lui et ses props n'ont l'aire de servir a rien 
Et pour finir on a un button qui est notre chevron qui prend en classe des conditons en cas de 
collapse falsy ou truly et en onClick il change l'etat de collapsed.     
 

Decription integrale Composant Events:

En premier on a une constante qui contient le numero 9, elle va nous permettre de reglé l'affichage 
des travaux a neuf par page.
Ensuite on rentre dans le composant EventList, il contient le hooks perso useData qui permet de recuperer les datas,
un state est initialiser pour le type, un autre est initialiser a (1) pour la page actuelle. 
Ensuite on a une variable "filteredEvents" (je pense que la crotte vient de la) qui permet de filtrer 
les events et de verifier si il sont present dan sla page actuelle. 
Ensuite on a la variable changeType qui va nous permettre de changer le type d'evenement selectionner, lors de la 
selection la page est réinitialisée a 1 et le type est mis a jour avec setType.
Ensuite on a la variable pageNumber qui calcule le nombre de page pour afficher les evenements filtrés.
Ensuite on a la variable typeList qui est un ensemble (Set) contenant tous les types d'événements uniques.
Maintent on rentre dans le return:
En premier on a une div qui est preparer au cas ou on une erreur truly
Ensuite on a une condition si data est null alors "loading" s'affiche sinon il s'affiche : 
Un h3, notre composant Select qui prend en prop selection la variable typeList puis en prop onChange la 
variable changeType. 
Ensuite on a une div "ListContainer", a l'interieur de celle ci on a filtered.map qui va appliquer un modale 
pour chaque events et une event cards pour chaque event. 
Puis on a un div "pagination" qui contient .... (revoir plus tard)

description composant DataContext : 
Tout ce composant est utiliser pour pouvoir gerer l'utilisation des Data et les transmettre au enfants sans 
passer par les props. A noter qu'il est programer de la meme façon que pourrais recuperer des Data sur une api
via un appel reseau (methode fetch). Chose qui est inutile car nos données sont deja presente en dur dans notre dossiers
dans le fichier (events.json).


SOLUTIONS :

filters:
L'erreur etait du au faite que dans le composant Events
filteredEvents manquer de cette condition ((!type || event.type === type) &&), modif aussi du ternaire
car il renvoyer deux fois la meme valeur (pas genant pour la fonctionnaliter des filtres mais plus propre)
Et que dans le composant Select il manquait dans l'élément input de selection.map (onChange={() => { onChange(s) }}).
PAR CONTRE PROBLEME D'AFFICHAGE J'AI SEULEMENT LA PAGE 1 QUI EST FILTRER LA 2eme N'EST PAS CALCULER, donc pour 
ce faire separation de la varaible filteredEvents en deux variable, une qui calcule les conditions de filtrages
(filteredByType) et une qui s'occupe de l'affichage des deux pages (filteredEvents) en faisant un slice de (filteredByType).
Ajout sur la balise li du map de selection, deux fonction (changeValue et onChange) qui permettent lors du clique sur le texte
de changer le filtre et de fermer la collapse. Ajout d'un span pour rendre le texte avec le cursor pointer et de couleur noir sinon 
invisible dans la partie formualire. 

event cards: 
Ajout de style et d'un modale background pour rendre la modale plus propre. 
Date des events cards regler avec getMonth, toute la conversion de l'ISO se prepare dans events cards (condition du test), 
puis dans Events le chemin de la props est donnée avec "new date" pour convertir ISO. 

Slider:
Apres un pacson de recherche le probleme dans le composant Slider concernant les unique Key ne venez que du
fragment (<> </>) c'est ce qui causer tout le bug avec le map slider qui englober aussi le map check des bullet point.
Ducoup supression des fragments, et separation bien distinct des deux map (slider et check) 

DataContext:
Utilisation de useMemo dans les props de DataProvider pour eviter de les rappeler a chaque render, useMemo 
utilise une fonction callback et un tableau de dependance pour stocker les valeurs et eviter de les 
recharger a render

FooterCard: 
Ajout d'un nouveau composant FooterCard pour pouvoir rendre plus propre le composant Home. 
Dans ce composant on a un d'abord un appel a la Data, ensuite on fouille un peu dans cette donnée pour pouvoir 
acceder au dernier event. Ajout d'un traitement d'erreur car sinon gros bug de secu liée au non traitement
de l'erreur. Puis Event qui a etait importer recois des props.  

formualaire: 
Apres verification c'était simplement la props OnSuccess qui n'etait pas passer dans le "try" car c'est cette 
props qui permet de rendre setIsOpenned "true", ajout d'un form.reset() pour permettre le nettoyage des champs,
a noter qu'il est placer en dernier du "try" pour eviter que les champs ne se vide avant l'envoi du formulaire. 

Header: 
lien d'encre entierement fonctionnel car de base il ne l'était pas. 

HTML:
Nettoyage du code html + ajout de resultat enrichie (SEO) + changement de favicon, nettoyage de manifest.json 

Fichier: 
nettoyage et ajustage de chaque fichier qui contenais des contrage d'erreur ESLINT. 

Home:
Chnagement des liens des icons footer remplacer par les bons. 



TOUT LES TEST PASS, PLUS AUCUNE ERREUR EN CONSOLE.



note depuis dernier commit:



A FAIRE UN FOIS SESSION DE MENTORAT FAITE:     
- peut etre empecher envoi du form si les fiels sont empty.
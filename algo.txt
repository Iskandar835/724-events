D'ABORD COMPRENDRE LE CODE DANS TOUT SES DETAILS ET ENSUITE PROPOSER DES SOLUTIONS:


Description integrale Composant Select: 

En premier on a un composant "Select" qui fabrique un collapse generic (utiliser dans 
le formulaire aussi). Il reçois plusieurs props (6 en tout). 
Ensuite des states sont mis en place, un pour la value et un qui initialise "truly" le collapse. 
On a ensuite une fonction changeValue qui est utiliser pour gerer la modification de la valeur du collapse (soirée, experience ..)
Maintenant place a l'élément return, il contient une premiere div "SelectContainer" qui va englober tout le collapse
Ensuite si label est true alors il fabrique une div qui va contenir le label,
Ensuite on a une div "Select" qui va englober le reste du code, dans cette div on a une ul qui contient un premier
li qui prend un parametre que si collapse est truly alors le titre est montrer sinon il est cacher. Dans cette 
li on a soit une value OU si titleEmpty est falsy alors il affiche la chaine "Toutes".
Maintenant on passe au reste de se container select car il va etre fait dynamiquement, on a un gros bout 
de code qui est contenu dans une condition : si collapse est falsy (donc ouvert) voici ce qui passe : 
On a un premier li qui est entourer de la condition si titleEmpty est falsy, il nous permet d'afficher par 
defaut le filtre "Toutes" et aussi de fabriquer un input ("Toutes") qui nous permettera de le selectionner. 
Ensuite on a un selection.map qui va nous mapper tout les element present dans selection ce qui va 
nous permettre d'avoir un li contenant un input radio pour chaque filtre. Cette li en Onclick il 
prend la fonction changeValue. 
Maintenant la ul se ferme 
Ensuite on a un input que lui et ses props n'ont l'aire de servir a rien 
Et pour finir on a un button qui est notre chevron qui prend en classe des conditons en cas de 
collapse falsy ou truly et en onClick il change l'etat de collapsed.     

Conclusion: 
Le composant Select est un composant generique qui sera utiliser aussi dans le formulaire, il 
est bien preparer en prop et en logique, il n'a quasiment aucun dure. Je ne pense pas que le probleme
des gestions de filtres vienne d'ici. 
 

Decription integrale Composant Events:

En premier on a une constante qui contient le numero 9, elle va nous permettre de reglé l'affichage 
des travaux a neuf par page.
Ensuite on rentre dans le composant EventList, il contient le hooks perso useData qui permet de recuperer les datas,
un state est initialiser pour le type, un autre est initialiser a (1) pour la page actuelle. 
Ensuite on a une variable "filteredEvents" (je pense que la crotte vient de la) qui permet de filtrer 
les events et de verifier si il sont present dan sla page actuelle. 
Ensuite on a la variable changeType qui va nous permettre de changer le type d'evenement selectionner, lors de la 
selection la page est réinitialisée a 1 et le type est mis a jour avec setType.
Ensuite on a la variable pageNumber qui calcule le nombre de page pour afficher les evenements filtrés.
Ensuite on a la variable typeList qui est un ensemble (Set) contenant tous les types d'événements uniques.
Maintent on rentre dans le return:
En premier on a une div qui est preparer au cas ou on une erreur truly
Ensuite on a une condition si data est null alors "loading" s'affiche sinon il s'affiche : 
Un h3, notre composant Select qui prend en prop selection la variable typeList puis en prop onChange la 
variable changeType. 
Ensuite on a une div "ListContainer", a l'interieur de celle ci on a filtered.map qui va appliquer un modale 
pour chaque events et une event cards pour chaque event. 
Puis on a un div "pagination" qui contient .... (revoir plus tard)


description composant DataContext : 
Tout ce composant est utiliser pour pouvoir gerer l'utilisation des Data et les transmettre au enfants sans 
passer par les props. A noter qu'il est programer de la meme façon que pourrais recuperer des Data sur une api
via un appel reseau (methode fetch). Chose qui est inutile car nos données sont deja presente en dur dans notre dossiers
dans le fichier (events.json).
La solution consisterais a changer tout les appels fetch asynchrone par une simple recuperation de Data via un import 
du fichier events.json car la plupart des erreurs dans la console sont peut etre lié au faite que que l'ai data sont demander 
mais il y l'async qui bloque. 


Probleme filter REGLER:
Apres verification les filtres marchent, l'erreur etait du au faite que dans le composant Events
filteredEvents manquer de cette condition ((!type || event.type === type) &&), modif aussi du ternaire
car il renvoyer deux fois la meme valeur (pas genant pour la fonctionnaliter des filtres mais plus propre)
Et que dans le composant Select il manquait dans l'élément input de selection.map (onChange={() => { onChange(s) }}).
PAR CONTRE PROBLEME D'AFFICHAGE J'AI SEULEMENT LA PAGE 1 QUI EST FILTRER LA 2eme N'EST PAS CALCULER, donc pour 
ce faire separation de la varaible filteredEvents en deux variable, une qui calcule les conditions de filtrages
(filteredByType) et une qui s'occupe de l'affichage des deux pages (filteredEvents) en faisant un slice de (filteredByType)

Probleme date event cards REGLER: 
Chemin de la props "date" entierement modifier et remplacer par periode + ajout de substring pour recuperer que le mois de la DATA
ajout de style et d'un modale background pour rendre la modale plus propre // Cette methode n'etais pas la bonne (d'apres OCR student mais voir avec mentor),
Date des events cards regler avec getMonth, toute la conversion de l'ISO se prepare dans events cards (condition du test), puis dans Events le chemin de la props
est donnée avec "new date" pour convertir ISO.  


Apres un pacson de recherche le probleme dans le composant Slider concernant les unique Key ne venez que du
fragment (<> </>) c'est ce qui causer tout le bug avec le map slider qui englober aussi le map check des bullet point.
Ducoup supression des fragments, et separation bien distinct des deux map (slider et check) 
Utilisation de useMemo dans les props de DataProvider pour eviter de les rappeler a chaque render, useMemo 
utilise une fonction callback et un tableau de dependance pour stocker les valeurs et eviter de les 
recharger a render

Probleme derniere prestation card REGLER: 
Ajout d'un nouveau composant FooterCard pour pouvoir rendre plus propre le composant Home. 
Dans ce composant on a un d'abord un appel a la Data, ensuite on fouille un peu dans cette donnée pour pouvoir 
acceder au dernier event. Ajout d'un traitement d'erreur car sinon gros bug de secu liée au non traitement
de l'erreur. Puis Event qui a etait importer recois des props.  


probleme formualaire d'envoi REGLER: 
Apres verification c'était simplement la props OnSuccess qui n'etait pas passer dans le "try" car c'est cette 
props qui permet de rendre setIsOpenned "true"




note depuis dernier commit:


A FAIRE ASAP:     
- peut etre revoir footercards (pas le bon event) car il faut la derniere presta par rapport a la date et non a l'id.
- (facultatif) revoir animation du select et aussi la photo un peu trop haute sur les eventscards (maybe max-heght) 
- Pour le cahier de recette il faudra le remplir depuis l'ordi du bureau (gros fichier word mais tres rapide) et ce le transferer. 


1 erreur de test: 

1 - lié au test de de Events, il me dit que je doit avoir un eventcards "forum #productCON"


Erreurs en test: 

- at Object.<anonymous> (src/components/EventCard/index.test.js:34:7)

 FAIL  src/containers/Events/index.test.js
  ● When Events is created › and we select a category › an filtered list is displayed                     
                                                     
    expect(element).not.toBeInTheDocument()          
                                                     
    expected document not to contain element, found <div class="EventCard__title">Forum #productCON</div> instead                                              

      84 |
      85 |       await screen.findByText("Conférence #productCON");
    > 86 |       expect(screen.queryByText("Forum #productCON")).not.toBeInTheDocument();
         |                                           
                ^
      87 |     });
      88 |   });
      89 |

      at Object.<anonymous> (src/containers/Events/index.test.js:86:59)

traduction: at Object.<anonymous> (src/components/EventCard/index.test.js:34:7)

FAIL src/containers/Events/index.test.js
● Lorsque Events est créé › et que nous sélectionnons une catégorie › une liste filtrée s'affiche

expect(element).not.toBeInTheDocument()

document attendu ne contenant pas d'élément, trouvé à la place <div class="EventCard__title">Forum #productCON</div>

84 |
85 | wait screen.findByText("Conférence #productCON");
> 86 | expect(screen.queryByText("Forum #productCON")).not.toBeInTheDocument();
|
^
87 | });
88 | });
89 |

à Object.<anonymous> (src/containers/Events/index.test.js:86:59)